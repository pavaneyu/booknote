---
title: JVM面试题
date: 2022年2月18日14:21:30
tags: []
categories: 学习笔记 
---


[toc]
# 内存泄漏与内存溢出

无法释放已申请的内存空间

进而导致新的应用没有足够的内存空间





# 类加载器

# 内存快照抓取

# 类加载过程

1.加载  ==双亲委派==  委托父类加载器   根加载器 ---> 拓展加载器 ---->应用程序加载器  

2.链接

+ 验证
+ 准备   在方法区内对静态变量分配内存,并初始化
+ 解析    JVM将常量池的   符号引用   替换为  直接引用

3.初始化

+ 执行clinit方法,   收集所有静态变量的赋值动作和静态代码块  并进行合并
+ JVM会保证一个类的clinit方法在多线程环境下被正确地加锁  同步

# 强引用与软引用?为什么要不同的引用类型

对GC回收时机不可控的补充 

+ 强引用   JVM不会回收 ,即使内存不足也不会被回收
+ 软引用   内存不足的时候才会回收



+ 弱引用   只要有GC操作就会进行回收 
+ 虚引用    任何时候都会被回收

# GC算法

+ 标记-清除   不需要额外空间  但是会产生内存碎片 而且需要两次扫描

+ 标记-整理     

+ 复制算法     对象存活度较低的时候使用,主要在新生区

时间复杂度最优 :复制算法>标记清除>标记整理

空间复杂度最优:标记清除=标记整理>复制算法

内存碎片最优:复制算法

# 轻GC与Full GC 分别在什么时候

新生代用轻GC  Full GC是全局范围的GC

# 垃圾收集器

CMS

# JVM分为哪些区(内存结构)?

+ 堆:   新生代   (伊甸 和幸存区  from  to)    老年代    元空间   
  +   堆是被所有线程共享,存放数组和变量,也是垃圾回收的主要区域
  +   其中在新生代 使用复制算法进行轻GC   经历了15次轻GC还未消亡就进老年代  或者根据分配担保机制大小超过时也会进入老年代
  +   老年代 使用标记清除和标记整理进行GC
+ 栈:每个线程都有一个栈,存放一些**基本类型和局部变量**
+ 方法区:所有线程共享,包含所有**类信息和静态变量**
+ 程序计数器:当前线程执行的字节码的行指示器



# 判断对象是否应该被回收

+ 引用计数法
+ 枚举根节点 做 可达性分析



# **获取class对象方式**

1.Class.forName()
2.Cat.class
3.对象.getClass()]
4.类加载器.loadClass(name) 



# JVM内存溢出怎么办?

1.加载数据过多   数据库查询分页                                    用的太多

2.垃圾没有GC   集合是否清空,资源是否释放                      历史积累太多

3.内存设定过小  JVM参数增加内存                                  给的太少

4.代码逻辑问题  有没有死循环递归                              自己问题

5.日志   用分析工具查看内存状态                        借助分析

   





# 判断废弃常量

假如在常量池中存在[字符串](https://so.csdn.net/so/search?q=字符串&spm=1001.2101.3001.7020) “abc”，如果当前没有任何String对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，

如果这时发生内存回收的话而且有必要的话，“abc” 就会被系统清理出常量池。



# 一些学习笔记

排查 死锁   

  jps -l                  查看运行程序  和pid

jstack +pid  查看堆栈信息
