---
title: 数据库面试题
date: 2022年2月18日14:21:30
tags: []
categories: 学习笔记 
---
[toc]

# 事务

## 事务ACID靠什么保证

+ 原子性:undolog日志保证,事务回滚时撤销已经执行的Sql
+ 一致性 由其他特性保证
+ 隔离性 由MVCC保证,也就是多版本并发控制,读写时不阻塞
+ 持久性  redolog日志   如果数据没有保存成功,还可以中日志中再次执行sql



## 事务七种传播行为

+ 需要 required     默认传播机制    有就加入 没有新建
+ 需要新的  required_new              必须新建,旧的挂起
+ 支持  support          有就加入 没有算了  
+ 不支持  notSupport   不应该运行在事务中  ,有就挂起
+ 强制 mandatory       必须运行在事务中,没有就抛出异常
+ 从不  never                不应该运行在事务中,有就抛出异常
+ 嵌套  nested            嵌套运行

## 事务隔离级别

+ 读取未提交内容  --产生**脏读**  幻读  不可重复读 很少用
+ 读取已提交内容 -- 解决了脏读问题     但还是有 有幻读   不可重复读  问题
+ 可重复读  -MySql的默认隔离级别 ,可能产生**幻读**  InnoDB引擎通过多版本并发控制来解决幻读问题
+ 串行化--最高级别的隔离,通过强制事务排序,在每个读的数据行加锁,但效率不高

## 事务三种隔离问题

+ 脏读   读取另一个事务未提交的数据
+ 幻读    两次读取前后数据总量不一致
+ 不可重复读   两次读取前后,数据内容不一致 

# mysql主从同步好处

+ 读写分离
+ 数据热备份
+ 降低IO频率

# sql调优

## 慢查询怎么处理

+ 可能加载了多余数据    分析**sql语句**优化   
+ 可能查询条件**没有命中索引**, 分析执行计划  修改或者增加索引
+ 查询**表自身的数据量**太大,可以考虑横向或纵向分表

## SQL优化

+ 避免  全表扫描 尽量走索引
  + like  避免字段开头模糊查询  
  + in 会全表扫描    可以用between  或者exist代替
  + or 也会 全表扫描   可以用union代替
  + where等号左边如果出现表达式和函数 也会全表扫描   

+ 查询优化 
  + 避免select *,尽量指定字段
  + 多表关联时,小表在前,大表在后    尽量内连接 
  + 用where替换having 
  + 查询数据量大,采用分页  
  
+ DML优化
  + 批处理,效率高一些
  + 适当commit ,减少事务占用的资源'
  
+ 索引优化  (查的更快,占用更少
  + 索引数目不要太多,删除不用的索引
  
  + 使用短索引, 和前缀索引
  
  + 经常 查询   的字段 建立索引
  
    

# InnoDB与Myisam ?

+ InnoDB          一定有主键,主键一定是聚集索引                 **行锁   支持事务            支持聚集索引     插入效率较高**    删除整个表是一行一行删除 
+ Myisam                               **表锁   不支持事务       非聚集索引      查询效率较高**    删除整个表会新建表 
  + 三个文件 myd存数据 myi存索引  frm存表结构  

![image-20220312131810702](https://s2.loli.net/2022/03/12/SoxZ73KQYctVapg.png)



# 索引

## 索引原理

+ 如果没有索引,查询就要遍历整张表  
+ 索引过程   --------首先给索引列  排序    然后生成倒排表      拼上数据地址链
+ 



## 聚集索引和非聚集索引

都是一种B+树  

+ 聚集索引: 按主键构造一颗 B+ 数，一张表存在一个          叶子节点中存放行数据,数据与索引放一起 ,物理连续            查询快,插入慢  

+  非聚集索引:叶子结点包含一个书签,指向索引对应的行数据           逻辑连续          

## 创建索引原则

+ 总的原则   (查询更快,空间更小)
+ 索引唯一性
+ 不要过度索引,索引数目尽量少,删除不用的索引
+ 使用短索引,尽量前缀创建索引
+ 经常查询  的字段建立索引
+ 有外键的数据列 一定要索引



+ 重复值较多的字段不适合建索引 ,比如 男女

+ 经常更改的字段不适合建索引   比如 updatetime
+ image 和bit 类型 不要建索引

## 有哪几种索引类型

+ 普通索引
+ unique唯一索引   主键索引
+ 联合索引
+ fulltext 全文索引
+ 索引可以提高查询速度，但是会占用一定的物理空间，而且在表更新后，索引文件也会跟着改变



## 索引下推

在联合索引情况下,不是有最左前缀原则  where name like 张% and age=20

会因为like导致后面的索引失效, 还是会全表扫描  

索引下推,仍然会通过索引树判断age     减少了回表次数 和IO操作

# 最左前缀原则

提供索引最左边的字段,也就是排在最前面的字段

比如在建立abc三个字段的联合索引时,底层b+树按照从左到右比较大小排序,

# 分库分表

+ 水平拆分  按照每一行的数据进行拆分   没有交集  提高sql执行效率
+ 垂直拆分   按每一列字段进行拆分  至少有一列交集





# mysql锁

+ 有好几种不同分类
+ 可以分为  行锁  表锁  间隙锁
+ 共享锁  也就是读锁  只允许其他事务读,但不能写   排它锁  也就是写锁,其他事物不能读,也不能写
+ 乐观锁,不是真的去锁,而是通过版本号来实现    悲观锁  行锁 表锁都是悲观锁





# mybatis相关



## mybatis 优缺点

+ sql 写在xml     与程序代码 解耦      支持动态sql
+ 基于jdbc 所以 jdbc支持的数据库  mybatis都支持   但是 相比于 直接用 jdbc   减少很多冗余代码  
+ 很容易与Spring集成
+ 
+ 手动写sql  编写量大   而且具体的sql 依赖于 数据库 ,所以写好了之后不能随便更换

##   #{}与${}

+ #{}  会预编译处理 ,相当于prepareStatement.set 赋值,可以防止sql注入
+ ${}  只是字符串替换 

## sql 模糊查询

concat函数  (‘%’,#{},’%’)

## 如何给sql 传参数

1. @param 参数列表     2.map传     3.javaBean 传 



## 动态sql 标签

+ choose   when      选择一个
+ where  if    查询条件动态
+ set  if   更新条件动态
+ foreach    遍历集合 

## 获取自动生成的主键  (回填到实体类)?

useGeneratedKeys="true" **keyProperty**="ID"  

java 完成插入后  可以自动获取 .getID

## mybatis 数据库字段  跟pojo中字段不一样怎么映射

+ sql语句中起别名 ,跟pojo对应 

+ .resultmap 映射
+ 如果只是驼峰和下划线的差别    mybatis配置文件中驼峰映射

## 嵌套查询与嵌套结果

嵌套查询是在查询 SQL 后再进行一个（子）查询  ,会执行多条Sql 

嵌套结果是一个多表查询的 SQL 语句 ,执行一条复杂sql

## 一对一  多对多

1. 联-association 用于一对一和多对一
2. 集合-collection 用于一对多的关系

## Mybatis三种Executor执行器:

+ 简单执行器**SimpleExecutor：**每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。

+ 重用执行器**ReuseExecutor：**执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map内，供下一次使用。简言之，就是重复使用Statement对象。

+ 批量执行器**BatchExecutor：**执行update。

+ Mybatis配置文件中，可以指定默认的ExecutorType执行器类型  

## mybatis  一二级缓存

+ 都是基于PerpetualCache ,HashMap存储
+ 一级缓存 作用域为 session   ,也就是session结束会清空.他是默认开启
+ 二级缓存 作用域为mapper ,可以在多个session之间共享, 他默认不开启 

## mp主键生成策略

自增长
UUID 每次生成随机唯一的值  但排序不方便
redis生成
mp默认的雪花算法

+ 

# B树和B+Tree 区别

+ b树 每个节点 key和数据在一起   b+树 数据在叶子节点上,且叶子节点之间相互引用  <img src="https://s2.loli.net/2022/03/07/jmSgiQZdqVW6zwE.png" alt="image-20220307172001114" style="zoom:50%;" />

# Sql调优之多个索引匹配?

创建索引的时候

覆盖索引  减伤回表次数 支持索引下推

普通索引





# MySQL常用函数

聚合函数   count   sum  max  min     avg

​       



#    左连接  右链接   内连接和全外连接

+ left join （左连接）：以左边表所有记录为标准         右表中连接字段相等的记录 ,没有显示null
  　　right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。
    inner join （内连接）：只返回两个表中连接字段相等的行。
+ full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录

------------------------------------------------



![image-20220312153155728](https://s2.loli.net/2022/03/12/k2jTh5DZfYdcQVC.png)

![image-20220312153340471](https://s2.loli.net/2022/03/12/68WOzi9X3kwUDPb.png)

# B+树

![image-20220312132403594](https://s2.loli.net/2022/03/12/4C2rTp7slFR5bhN.png)
